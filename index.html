<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>reveal.js - The HTML Presentation Framework</title>

        <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
        <meta name="author" content="Hakim El Hattab">

        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/league.css" id="theme">

        <!-- Code syntax highlighting -->
        <!-- <link rel="stylesheet" href="lib/css/monokai_sublime.css"> -->
        <!-- <link rel="stylesheet" href="https://highlightjs.org/static/demo/styles/atom-one-dark.css"> -->
        <link rel="stylesheet" href="https://highlightjs.org/static/demo/styles/monokai-sublime.css">


        <style type="text/css">
        .reveal{font-size:24px}
        .txl{text-align:left;display:inline-block}
        </style>
        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>

        <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>

    <body>
        <div class="reveal">
            <!-- Any section element inside of this container is displayed as a slide -->
            <div class="slides">
                <section>
                    <img src="img/js.png" alt="" style="max-width:20%">
                    <h1>ECMAScript 6ㆍ2015 and Javascript</h1>
                    <!-- <h1>Introduction to ECMAScript 6ㆍ2015 and Javascript</h1> -->
                    <p>2017. 1. 11.</p>
                    <p>IT 개발2팀 UI파트 - 김재호</p>
                </section>

                <section>
                    <section>
                        <h2>ECMAScript 6 / ES2015 / 에크마?</h2>
                        <a href="http://www.ecma-international.org/publications/standards/Standard.htm" target="_blank"><img src="img/Ecma_international_Logo.png" alt=""></a>

                        <p>ecma인터내셔널의 ECMA-262 기술 규격에 정의된 표준화된 스크립트 프로그래밍 언어.</p>
                        <p>즉, JavaScript의 표준화된 버전.</p>
                        <p>ECMAScript 뒤에 숫자 버전을 의미하고, 다른 하나는 출시된 연도를 의미.</p>
                        <p>ES2016부터는 <strong>'해마다 표준이 추가됨'</strong>을 강조하고자<br> ES뒤에 해당 년도를 붙인 것만 정식 명칭.</p>

                        <aside class="notes">
우리가 흔히 JavaScript라고 부르는 언어는 Ecma 인터내셔널의 ECMA-262 기술 규격에 정의된 표준화된 스크립트 프로그래밍 언어.

ECMAScript 를 기반으로 하는 언어는 JavaScript 만 있는 것은 아니고, 예전 MicroSoft 사의 JScript 나 Adobe의 Action Script 등이 있다.
                        </aside>
                    </section>

                    <section>
                        <h2>History</h2>
                        <p>현재 ECMA-262는 ECMAScript 2016 버전(2016년 6월)이 최신버전.</p>
                        <img src="img/javascript-myths-and-its-evolution-12-638.jpg" alt="" style="max-width:38%">
                         <ul style="float:right;padding:10px 0 0 10px">
                            <li><em>ECMAScript 1 :</em> 1997</li>
                            <li><em>ECMAScript 2 :</em> 1998</li>
                            <li><em>ECMAScript 3 :</em> 1999</li>
                            <li><em>ECMAScript 4 :</em> 포기됨</li>
                            <li><em>ECMAScript 5 :</em> 2009 (현재 가장 많이 사용)</li>
                            <li><em>ECMAScript 6 :</em> 2015 (가장 큰 기능 상의 변화)</li>
                            <li><em>ECMAScript 2016(ES7) :</em> 2016</li>
                            <li><em>ECMAScript 2017(ES8) :</em> 작업중(올해 중반)</li>
                        </ul>
                    </section>

                    <aside class="notes">


ECMA International 에서는 지속적으로 언어 규격을 변화시키고 발전시키려 노력했고 그 결과로 4번째 판을 제안하게 되었지만 많은 반대에 부딪혀 흐지부지되고 만다.
ECMAScript 에디션 4를 위해 아주 많은 작업들이 진행됐습니다.
하지만 에디션 4에는 모호한 구석이 너무 많았기 때문에 폐기됐습니다.

10년만인 2009년 출시된 ECMAScript 5(ES5)는 HTML5와 함께 출현한 표준안이다.

ES5에서 ES6로의 버전업이 가장 큰 기능 상의 변화가 있었고
ES6는 당신의 JS 코드 작성 방식을 바꿀 것입니다.
이후의 버전업은 작은 기능의 추가 레벨로 매년 공개할 것으로 예고되었다.


JavaScript는 넷스케이프에 탑재하기 위해 개발된 언어였다.
브렌던 에이크(Brendan Eich)가 10일안에 만드는 조건으로 입사한뒤 언어 개발에 착수했다.
처음에는 모카(Mocha)라는 이름으로, 나중에는 라이브스크립트(LiveScript)라는 이름으로 개발하였으며, 최종적으로 자바스크립트가 되었다.

마이크로소프트도 이런 시류에 편승하여 Internet Explorer 3.0에 JScript가 개발되어 탑재
상표 문제를 회피하기 위한 이름만 다른 언어

그 이후 ECMAScript 표준을 따르는 JavaScript 표준이 제안되기 시작

ECMA International 에서는 지속적으로 언어 규격을 변화시키고 발전시키려 노력했고 그 결과로 4번째 판을 제안하게 되었지만 많은 반대에 부딪혀 흐지부지되고 만다.
ECMAScript 에디션 4를 위해 아주 많은 작업들이 진행됐습니다.
하지만 에디션 4에는 모호한 구석이 너무 많았기 때문에 폐기됐습니다.


4판의 규격에는 JavaScript의 본질과 많이 다른 이질적인 느낌의 특성을 다수 도입하는 내용
이 큰 변화에 대한 반발은 거셌다.
이 변화 내용에 대해서 더글라스 크락포드 등의 유명한 JavaScript 관련 프로그래머들은 강하게 반발했으며 ECMAScript 4에 제동


                    </aside>


                    <section>
                        <h2>ECMAScript 6의 새로운 기능들</h2>

                        <p>let, const, Arrow Functions, Classes, Module system, Reflect, Promise, Proxy, Generators and iterators, Destructuring assignment, etc, ...</p>

                        <img src="img/react.png" alt="" style="max-width:21.2%">
                        <img src="img/angular2.png" alt="" style="max-width:20%">
                        <p>기존 스크립트 버전의 호환성, 복잡한 웹애플리케이션 개발에 적합한 기능.<br>더블어 React, Angular2 ES6 지원.</p>

                        <aside class="notes">
                        사실 주요 브라우저들이 벌써 ES6 기능들을 일부 지원하고 있구요 기존에 JS 코드도 잘 동작합니다.
                        ES6는 기존 코드와 최대한 호환되도록 설계되었구요 클래스와 모듈 같은 복잡한 응용 프로그램을 작성하기 위한 새로운 문법이 추가 되었습니다.
                        트랜드나 선택이 아니라 필수로 자리매김 하는 분위기
                        </aside>
                    </section>


                    <section>
                        <h2>ECMAScript 6 지원 현황</h2>
                        <p>현재 Internet Explorer를 제외한 대부분의 최신 브라우저는 표준을 지원하는 상황</p>
                        <a href="https://kangax.github.io/compat-table/es6/" target="_blank"><img src="img/compat-table.png" alt=""></a>
                        <p style="margin-top:0">Source: ES6기능 지원여부 호환성 표(칸자스)</p>
                        <aside class="notes">
                        node.js, 크롬, 파이폭스, 엣지는 상당부분 사용가능 합니다.
                        IE11의 ES6 지원율은 심히 안습 입니다.
                        </aside>
                    </section>

                    <section>
                        <h2>비호환 엔진에서 ECMAScript 6 사용</h2>

                        <img src="img/babel.png" alt="" style="max-width:30%">

                        <h3>트랜스파일러(transpiler)</h3>
                        <ul>
                            <li>ES6 문법 코드를 ES5 소스코드로 변환하는 도구</li>
                            <li><a href="https://github.com/google/traceur-compiler" target="_blank">구글 트레이서</a>, <a href="https://babeljs.io/" target="_blank">바벨</a> 등 (깃헙 상태를 보면 바벨을 가장 많이 사용)</li>
                        </ul>

                        <h3 style="margin-top:40px">폴리필(polyfill)</h3>
                        <ul>
                            <li>특정 기능이 지원되지 않는 브라우저를 위해 사용할 수 있는 코드 조각. (<a href="https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills#ecmascript" target="_blank">폴리필 목록</a>)</li>
                        </ul>

                        <aside class="notes">
크로스 브라우징을 염두해 트랜스파이일러, 폴리필을 사용해서  ES6 문법을 사용할 수 있습니다.
IE에서는 트랜스파이일러 및 폴리필 사용필수입니다.

트랜스파일러란, ES6 문법 코드를 ES5코드로 변환해서 지금 사용 중인 브라우저에서도 사용할 수 있게 변환하는 도구입니다.
바벨을 쓴다고 해서 ES6의 모든 문법을 쓸 수 있는 것은 아닙니다.

바벨 문서를 읽어보면 일부 기능들은 폴리필(Polyfill)을 불러와야 쓸 수 있다고 명시되어있죠.
폴리필 역시 특정 기능이 지원되지 않는 브라우저를 위해 사용할 수 있는 코드 조각입니다.
                        </aside>
                    </section>
                </section>


                <section>
                    <section>
                        <h2>let, const</h2>
                    </section>

                    <section>
                        <h2>var <span style="display:inline-block;padding:0 14px;color:#13DAEC">vs</span> letㆍconst</h2>
                        <ul>
                            <li style="list-style:none"><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var :</strong> 함수 스코프 (function scope)</li>
                            <li style="list-style:none"><strong>letㆍconst :</strong> 블록 스코프 (block scope)</li>
                        </ul>
                    </section>

                    <section>
                        <h2>함수 스코프 변수</h2>
                        <ul>
                            <li>var 키워드로 선언</li>
                            <li>함수 밖에 선언 시, 전역범위로 스크립트 끝에서도 참조가능</li>
                            <li>함수 안에 선언 시, 함수 밖을 제외한 내부 어디서든 접근가능</li>
                        </ul>
                    </section>
                    <section>
                        <h2>예기치 않은 결과</h2>
                         <p>Why no ReferenceError?</p>
                        <pre><code>
    var a = 12; //전역 접근 가능

    function myFunction() {
        console.log(a); // -> 12
        console.log(b); // -> undefined??

        if(true) {
            var b = 13;
        } else {
            var c = 14
        }

        console.log(c); // -> 14
    }

    myFunction();
                        </code></pre>

                        <aside class="notes">
var를 통한 변수 선언시 예기치 않은 결과가 발생할 수 있습니다.
if문 밖에서도 변수 b는 접근 가능하지만 다른 언어에선 어림없는 소리
변수를 선언한 곳보다 더 위에서 해당 변수에 접근할 수 있는 경우가 있었습니다.

다음에 나올 호이스팅 개념을 이해하면 유연하다
타언어 개발자들은 허술하다 부실하다 라고 자바스크립트를 낮게 평가하는 경향
                        </aside>
                    </section>

                    <section>
                        <h2>Hoisting(호이스팅) 이란?</h2>
                        <p>코드를 해석하기 전 var 선언 범위를 상단으로 이동 합니다.</p>
                        <pre><code>
    function myFunction() {
        //var b, c; -> 변수는 호이스트 되었습니다.
        console.log(b); // -> undefined

        if(true) {
            var b = 13; //b 값이 할당 되었습니다.
        } else {
            var c = 14
        }

        console.log(b); // -> 13
        console.log(c); // -> 14
    }
                        </code></pre>

                        <aside class="notes">
변수의 선언과 변수의 할당을 구분하겠다는 개념입니다.
즉, 함수내의 선언된 어떤 위치의 변수든 함수의 최상단으로 끌어올려집니다.
그리고는 undefined로 임의의 값을 할당합니다.
그리고 나중에 함수가 실행이 되면서 그 변수에 해당하는 값을 할당합니다.

위의 코드는 분명히 에러가 나야 하는 상황입니다.
b라는 변수가 선언이 되지도 않았는데 b변수를 이미 호출해서 사용했습니다. 그런데 에러는 나지 않습니다.
즉 변수의 선언이 먼저되어 있음을 알수 있습니다.
할당은 그 이후에 해당 코드가 실행이 되면서 이뤄졌습니다.
이 개념이 바로 자바스크립트에서의 호이스팅의 개념입니다.
                        </aside>
                    </section>



                    <section>
                        <h2>블록 스코프 변수</h2>
                        <ul>
                            <li>let, const 키워드로 선언</li>
                            <li>함수 밖에 선언 시, 전역 접근 가능</li>
                            <li>블록 안에 선언 시, 자신을 정의한 블록 또는 그 하위 블록에서만 접근 가능</li>
                        </ul>
                    </section>

                    <section>
                        <h2>let 변수 선언</h2>
                        <p>변수 범위를 가장 가까운 블록으로 지정, 호이스팅되지 않습니다.<br>일시적 사각지대(Temporal Dead Zone; TDZ) 존재</p>
                        <pre><code>
    let a = 12; //전역 접근 가능

    function myFunction() {
        console.log(a); // -> 12
        console.log(b); // -> ReferenceError: b is not defined

        if(true) {
            let b = 13; //if 불록 밖에서 접근 할 수 없음
        } else {
            let c = 14 //else 불록 밖에서 접근 할 수 없음
        }

        console.log(c); // -> ReferenceError: c is not defined
    }

    myFunction();
                        </code></pre>

                        <aside class="notes">
                        그래서 블록 스코프를 변수를 생성하기 위해 let 키워드가 탄생
                        let을 사용하면 변수가 각각의 if와 else 블록 안에 사용됩니다.
                        이제 타 언어 개발자도 헷갈리지 않는 결과가 나옵니다.
                        </aside>
                    </section>

                    <section>
                        <h2>for반복문 안에서 var 문제</h2>
                        <ul>
                            <li>var i는 함수 상단으로 끌어 올려지고 for loop 반복마다 공유됩니다.</li>
                            <li>setTimeout 콜백이 호출되기 전 i는 각 반복마다 증가 됩니다.</li>
                            <li>콜백이 실행되면 i는 for 반복문에서 할당 된 마지막 값을 보유합니다.</li>
                        </ul>
                        <pre><code>
    function myFunction(){
        //var i;
        //for (i = 0; i < 5; i++) {

        for (var i = 0; i < 5; i++) {
            //콜백은 비동기이기 때문에 임의의 실행 전에, 반복문이 완료
            setTimeout(function() {
               console.log(i);
            }, i * 1000);
        }
        // -> 예상하는 결과 0 1 2 3 4
        // -> 5 5 5 5 5 예상과는 다르게 모든 반복에서 같은 값을 출력
    }
                        </code></pre>

                        <aside class="notes">
루프안에서 비동기 범위 지정 문제 입니다.

변수 i에서 for루프 초기화는 글로벌 범위
콜백에 전달 setTimeout()이 글로벌 참조i
콜백은 비동기이기 때문에 임의의 실행 전에, 루프가 완료
콜백을 실행 할 때, for루프는 이미 전역 변수 증가했다 i값 (5)를 유지하는 단계
                        </aside>
                    </section>


                    <section>
                        <h2>for반복문 안에서 let 사용</h2>
                        <p>let은 for 반복문 안에서 공유되지 않고, 각 반복마다 새로운 변수가 생성됩니다.</p>
                        <pre><code>
    function myFunction(){
        for (let i = 0; i < 5; i++) {
            setTimeout( () => console.log(i), i * 1000 );
        }

        // -> 0 1 2 3 4
        //각 반복에서 올바른 값을 출력
    }
                        </code></pre>

                        <aside class="notes">
                        for loop 안 에서는 let 바인딩을 매 룹마다 새로 생성해서, 반복문에서 잘못된 바인딩을 참조하는 흔한 실수를 방지할 수 있습니다.
                        </aside>
                    </section>

                    <section>
                        <h2>변수 재선언 시</h2>
                        <p>let으로 선언된 변수는 같은 범위 내에서 동일한 변수 명을 사용 할 수 없습니다.</p>
                        <pre><code>
    //ES5
    var message = 'Hello';
    var message = 'Goodbye';
    console.log(message); // -> Goodbye

    //ES6
    let message = 'Hello';
    let message = 'Goodbye'; //재선언은 허용되지 않음
    //Uncaught SyntaxError: Identifier 'message' has already been declared

    let message = 'Hello';

    function myFunction(){
        let message = 'Goodbye'; //다른범위에서는 허용
    }
                        </code></pre>

                        <aside class="notes">
같은 스코프에서 var로 선언한 변수를 다시 var로 선언하면 덮어씁니다.
                        </aside>
                    </section>

                    <section>
                        <h2>const 변수 선언 (상수)</h2>
                        <ul>
                            <li>일기전용 변수, 항상 초기값을 할당 해야합니다.</li>
                            <li>값이 할당되면 새로운 값을 재할당 할 수 없습니다.</li>
                        </ul>
                        <pre><code>
    //ES5
    function loadProfiles(userNames){
        //Magic Number. 3 그 자체로 명확한 의미를 알 수 없습니다.
        if(userNames.length > 3){
            //...
        }
    }

    //ES6
    function loadProfiles(userNames){
        const MAX_REPLIES; //Uncaught SyntaxError: Missing initializer in const declaration
        const MAX_USERS = 3;
        MAX_USERS = 10; //Uncaught TypeError: Assignment to constant variable.

        if(userNames.length > MAX_USERS){
            //...
        }
    }
                        </code></pre>

                        <aside class="notes">
                        이전에는 변수명 앞에 어떤 문자열을 붙여 상수처럼 보이게 했다.
                        const를 사용하면 절대 바꿔서는 안 되는 값을 실수로 변경 되는것을 예방 할 수 있다.
                        상수값을 바꾸려하면 읽기 전용 예외가 난다.
                        </aside>
                    </section>

                     <section>
                        <h2>하지만 조심해야 할 점</h2>
                        <p>const는 다시 대입하는 것만 막지,<br> 할당된 객체나 배열의 요소를 바꾸는 것은 막지 않습니다.</p>
                        <pre><code>
    //배열
    const myArrary = [1, 2, 3];
    myArrary[0] = 4;
    console.log(myArrary); // -> [4, 2, 3]

    //객체
    const myObject = {name: 'Zero'};
    myObject.name = 'One';
    console.log(myObject); // -> {name: 'One'}

    myObject = {}; //Uncaught TypeError: Assignment to constant variable
                        </code></pre>

                        <aside class="notes">
                        즉, = 대입연산자를 통한 대입만 막은 거죠.
                        변수 d는 객체의 주소, 즉 참조값을 담고 있으므로 불변값, 객체 자신은 얼마든지 변경가능
                        다른 객체를 d에 할당하면 d값을 바꾸려는 시도라 예외가 발생
                        </aside>
                    </section>

                    <section>
                        <h2>var, let 둘 중 어느 것을 사용해야 하나요?</h2>
                        <p>ES6 코드라면 이제 let을 사용하세요. 사실상 var은 이제 사용할 일이 없습니다.</p>
                        <ul>
                            <li>변수에 새로운 값을 재할당 하려면 let</li>
                            <li>변수에 새로운 값을 재할당 하지 않으려면 const</li>
                        </ul>

                        <aside class="notes">
                        대부분의 경우 let과 const는 매우 유사하게 동작합니다.
                        let 과 const는 가장 가까운 블록에 스코핑을 가집니다.
                        기억도 잘 되고 코드를 읽기가 쉬우며, 스코프를 착각할 일이 줄고 끔찍한 버그를 일으킬 확률도 낮아진다.
                        사실상 이제 var은 사용할 일이 없습니다. var의 기능은 let이 거의 다 하거든요.
                        </aside>
                    </section>

                </section>

                <section>
                    <section>
                        <h2>functions</h2>
                    </section>

                    <section>
                        <h2>default parameter (파라미터 기본값)</h2>
                        <p>parameter에 임의의 기본값을 지정할 수 있게 하는 새로운 방법을 제공.</p>

                        <pre><code>
    //ES5
    function myFunction(x, y, z){
        x = typeof x !== 'undefined' ? x : 1;
        y = typeof y !== 'undefined' ? y : 2;
        z = typeof z !== 'undefined' ? z : 3;
    }

    //ES6
    function myFunction(x = 1, y = 2, z = 3){ //파라미터 누락 시 기본값을 사용
        console.log(x, y, z);
    }

    myFunction(6, 7); // -> 6, 7, 3
                        </code></pre>

                        <aside class="notes">
                        전달된 각 parameter의 타입을 확인해서 전달받지 못한 파라미터를 미리 정해진 기본값을 지정해서 사용하는 패턴이 많이 쓰인다.
                        </aside>
                    </section>


                    <section>
                        <h2>... rest parameter (나머지 파라미터)</h2>
                        <p style="text-align:left">함수의 파라미터 수를 예상할 수 없을 경우에 유용.<br>점(dot) 3개 이 후 파라미터 명을 설정하면 나머지 파라미터가 배열 객체로 넘어옵니다.</p>

                        <pre><code>
    //ES5
    function myFunction(a, b) {
        var args = Array.prototype.slice.call(arguments, myFunction.length);
        console.log(args); // -> 3, 4, 5
    }

    //ES6
    function myFunction(a, b, ...args) {
        console.log(args); // -> 3, 4, 5
    }

    myFunction(1, 2, 3, 4, 5);
                        </code></pre>

                        <aside class="notes">
                        ES5에서 함수 파라미터를 임의의 수를 받기를 원한다면 반드시 특별 변수인 arguments를 사용해야 합니다.
                        </aside>
                    </section>

                     <section>
                        <h2>arguments는 이제 그만</h2>
                        <p>rest / default parameter는 arguments 객체를 대체하고<br> 좀 더 풍부하고 가독성 좋은 표현으로 자바스크립트 함수를 선언할 수 있게 합니다.</p>
                    </section>


                    <section>
                        <h2>... spread operator (펼침 연산자)</h2>
                        <p style="text-align:left">펼침 연산자는 여러 파라미터, 여러 배열이 예상되는 곳에 각각의 요소 값을 전달 합니다.</p>
                        <pre><code>
    function myFunction(a, b) {
        return a + b;
    }

    //ES5
    var data = [1, 4];
    var sum = myFunction.apply(null, data); //배열을 함수 파라미터로 사용 시


    //ES6
    let data = [1, 4];
    let sum = myFunction(...data);
    //...data를 먼저 1, 4로 치환 -> myFunction함수 호출

    console.log(sum); // -> 5
                        </code></pre>

                        <aside class="notes">
                        배열을 apply()메소드를 통해 함수 파라미터로 변환합니다. ES6은 이 목적을 위해 펼침 연산자를 갖는다.
                        </aside>
                    </section>


                    <section>
                        <h2>더 강력한 배열 리터럴 (펼침 연산자)</h2>
                        <pre><code>
    let arr1 = [1, 2];
    let arr2 = [3];
    let arr3 = [4, 5];

    //여러 배열 병합
    //ES5 – concat()
    console.log(arr1.concat(arr2, arr3)); // -> [1, 2, 3, 4, 5]
    //ES6
    console.log([...arr1, ...arr2, ...arr3]); // -> [1, 2, 3, 4, 5]

    //다른 배열에 밀어 넣기
    //ES5 – apply()
    arr1.push.apply(arr1, arr2);
    console.log(arr1); // -> [1, 2, 3]
    //ES6
    arr1.push(...arr2);
    console.log(arr1); // -> [1, 2, 3]

    //문자열을 배열로 치환
    const chars = [...'abc'];
    console.log(chars); // -> ['a', 'b', 'c']
                        </code></pre>

                        <aside class="notes">
                        push, splice, concat 등의 조합을 사용..
                        펼침 연산자 구문은 훨씬 더 간결해집니다
                        concat() 이라는 메소드(함수)에, 합쳐야 할 배열명을 넣어주면, 합친 결과를 반환합니다.
                        </aside>

                    </section>


                    <section>
                        <h2>arrow function (화살표 함수)</h2>
                        <p>순수 함수로서의 기능만을 담당하기 위해 간소화한 함수</p>
                        <ul>
                            <li>"=>" 좌측에는 parameter, 우측에는 return될 내용.</li>
                            <li>여러줄 일 경우 { ... }로 묶을 수 있습니다.</li>
                        </ul>

                        <pre><code>
    //Arrow function 문법
        () => { ... } // no parameter
         x => { ... } // one parameter, an identifier
    (x, y) => { ... } // several parameters
                        </code></pre>

                        <pre><code>
    //ES5
    var addition = function(a, b) {
        return a + b;
    };

    //ES6
    let addition = (a, b) => a + b;
                        </code></pre>

                        <aside class="notes">
                            화살표(arrow) 함수는 =>를 쓰는 표현식을 말하는데 function의 줄임 표현이다.
                            한 줄일 경우는 {}을 사용하지 않고 자동 return 구문이 된다.
                        </aside>
                    </section>


                    <section>
                        <h2>함수 호출 패턴과 this 바인딩</h2>
                        <p>Javascript 함수는 4가지 방식으로 호출.<br >그리고 함수 호출 패턴에 따라 this의 참조값이 달라집니다.</p>
                        <ul>
                            <li>메소드 호출 패턴</li>
                            <li>함수 호출 패턴</li>
                            <li>생성자 호출 패턴</li>
                            <li>call, apply 호출 패턴</li>
                        </ul>

                        <aside class="notes">
자바스크립트의 함수는 호출될 때, 매개변수로 전달되는 인자값 이외에, arguments 객체와 this를 암묵적으로 전달 받는다.
                        </aside>
                    </section>

                    <section>
                        <h2>메소드 호출 패턴</h2>
                        <p>함수가 객체의 속성이면 메소드 내부의 this는<br> 해당 메소드를 호출한 객체에 바인딩 됩니다.</p>
                        <pre><code>
    var obj1 = {
        name: 'Lee',
        sayName: function() {
            console.log(this.name);
        }
    }

    var obj2 = {
        name: 'Kim'
    }

    obj2.sayName = obj1.sayName;

    obj1.sayName(); //this는 obj1, this.name -> Lee
    obj2.sayName(); //this는 obj2, this.name -> Kim
                        </code></pre>

                        <aside class="notes">
                        함수가 객체의 속성이면 메소드 호출 패턴으로 호출됩니다.
                        </aside>
                    </section>

                    <section>
                        <h2>함수 호출 패턴</h2>
                        <p>일반 함수에서 this는 기본적으로 전역객체(window)에 바인딩. <br>전역함수는 물론이고, 내부함수의 경우도 this는 전역객체에 바인딩 됩니다.</p>
                        <pre><code>
    console.log(this === window); // true

    function foo() {
        console.log('foo this: ',  this); //window

        function bar() {
            console.log('bar this: ', this); //window
        }

        bar();
    }

    foo();
                        </code></pre>

                        <aside class="notes">

                        </aside>
                    </section>

                    <section>
                        <p>그리고 객체 속성 메소드의 내부함수일 경우에도 this는 전역객체에 바인딩.</p>
                        <pre><code>
    var value = 1;

    var obj = {
        value: 100,
        foo: function() {

            console.log('foo this: ',  this); //obj
            console.log('foo this.value: ',  this.value); //100

            function bar() {
                console.log('bar this: ',  this); //window
                console.log('bar this.value: ', this.value); //1
            }

            bar();
        }
    }

    obj.foo();
                        </code></pre>

                        <aside class="notes">
                        메소드 호출 패턴이든 함수 호출 패턴이든 내부함수의 this는 모두 전역객체에 바인딩된다.
                        </aside>
                    </section>

                    <section>
                        <h2>생성자 호출 패턴</h2>
                        <p>생성자 함수를 호출하면 this는 새로 생성되는 객체에 바인딩 됩니다.</p>
                        <pre><code>
    function Person(name) {
        this.name = name;
        console.log(this.name);
    }

    var me = new Person('Kim'); //this.name -> Kim
    var you = new Person('Lee');  //this.name -> Lee
                        </code></pre>

                        <aside class="notes">
                        함수 호출이 new 키워드가 앞에 나오게 되서 호출 되면, 생성자 호출 입니다.

                        자바스크립트의 생성자 함수는 말 그대로 객체를 생성하는 역할을 한다.
                        새로운 객체는 생성자의 속성과 메소드를 상속 받습니다.

                        일반 함수를 호출하면 this는 전역객체에 바인딩되지만 생성자 함수를 호출하면 this는 새로 생성되는 객체에 바인딩된다.
                        </aside>
                    </section>

                    <section>
                        <p>생성자 함수의 내부함수 역시, this는 전역객체에 바인딩 됩니다.</p>
                        <pre><code>
    function Person() {
        this.age = 0;

        setInterval(function() {
            //this는 전역객체(window)를 가리키므로 동작하지 않습니다.
            this.age++;
        }, 1000);
    }

    var me = new Person(); //this.age는 NaN
                        </code></pre>

                        <aside class="notes">

                        </aside>
                    </section>


                    <section>
                        <h3>내부함수의 this가 전역객체 참조를 회피하는 방법</h3>
                        <ul>
                            <li>일반적으로 this를 다른변수에 할당하는 방법</li>
                            <li>ES5 Function.prototype.bind()로 this를 바인딩</li>
                            <li>Function.prototype.apply(), Function.prototype.call()</li>
                        </ul>
                        <pre><code>
    function Person() {
        var self = this;
        this.age = 0;

        setInterval(function() {
            self.age++;
        }, 1000);

        //bind
        setInterval(function() {
            this.age++;
        }.bind(this));
    }

    var me = new Person(); //이제 this.age는 올바르게 증가합니다.
                        </code></pre>

                        <aside class="notes">
call()과 apply()는 미리 선언된 자바스크립트 함수 메소드입니다.
두 메소드는 함수 호출 시 사용되어 지고, 첫 매개변수로 주인 객체를 갖습니다.
                        </aside>
                    </section>

                    <section>
                        <h2>화살표 함수에서의 this</h2>
                        <p>화살표 함수의 사용으로 직관적인 this를 사용할 수 있습니다.</p>
                        <pre><code>
    //ES6
    function Person() {
        this.age = 0;

        setInterval(() => {
            this.age++; //'this'는 Person의 객체를 제대로 참조합니다.
        }, 1000);
    }

    var me = new Person(); //this.age는 올바르게 증가합니다.
                        </code></pre>

                        <aside class="notes">
                        화살표 함수에서 this는 해당 스코프의 this값과 같습니다.
                        </aside>
                    </section>


                    <section>
                        <h2>화살표 함수와 일반 함수의 차이점</h2>
                        <p>화살표 함수는 객체 생성자로 즉, new 연산자를 사용할 수 없습니다.</p>
                    </section>

                </section>

                 <section>
                    <section><h2>destructure assignment</h2></section>

                    <section>
                        <h2>배열 해체 할당</h2>
                        <pre class="vertical"><code>
    //ES5
    var myArray = [1, 2, 3];
    var a = myArrary[0];
    var b = myArrary[1];
    var c = myArrary[2];

    console.log(a); //1
    console.log(b); //2
    console.log(c); //3
                        </code></pre>

                        <pre class="vertical"><code>
    //ES6
    let myArray = [1, 2, 3];
    let [a, b, c] = myArray;



    console.log(a); //1
    console.log(b); //2
    console.log(c); //3
                        </code></pre>
                        <aside class="notes">
                            배열 혹은 객체를 해체하여 각각 변수에 할당한다
                            단순희 배열 값을 하나씩 뽑아 a,b,c에 할당
                            배열 해체할당을 사용하면, 변수의 값에 쉽게 배열의 값을 할당할 수 있습니다.
                            할당문 좌변에는 할당할 변수를 배열 형식으로, 우변은 데이터를 가져올 배열을 놓습니다.
                        </aside>
                    </section>

                    <section>
                        <h2>객체 해체 할당</h2>
                        <pre class="vertical"><code>
    //ES5
    var user = {
            'name': '민호',
            'age' : 23
        };

    var name = user.name;
    var age = user.age;



    console.log(name); //민호
    console.log(age); //23
                        </code></pre>
                        <pre class="vertical"><code>
    //ES6
    let user = {
            'name': '민호',
            'age' : 23
        };

    let {name, age} = user;

    //다른 변수명 사용 시
    let {name: x, age: y} = user;

    console.log(x); //민호
    console.log(y); //23
                        </code></pre>
                        <aside class="notes">
                            객체 프로퍼티 값을 다른 변수에 할당하려면 이 방법뿐이었습니다.
                            객체 해체 할당은 객체 프로퍼티 값을 추출해서 변수에 할당합니다.
                            좌변에는 리터럴 방식으로 할당할 변수를 열거하고, 우변은 객체를 놓은 뒤 전체를 ()로 감쌉니다.
                            객체 프로퍼티명과 변수명은 반드시 같아야 합니다.
                        </aside>
                    </section>
                </section>


                <section>
                    <section><h2>for-of</h2></section>

                    <section>
                        <h2>배열 루프 순회하기</h2>

                        <pre><code>
    //ES5
    var array = ['a', 'b', 'c', 'd'];

    for (var i = 0; i < array.length; i++) {
        var element = array[i];
    }

    // forEach
    array.forEach(function (element) {
      //break, return 구문을 사용해 함수를 벗어날 수 없음
    });

    //for–in 루프 구문은 객체의 속성들을 순회하기 위한 구문
    //실제 상황에서는 사용하지 마세요
    for (let element in array) {
      //브라우저에 따라 요소들의 순서가 보장되지 않음
    }

                        </code></pre>

                        <aside class="notes">

                        </aside>
                    </section>

                    <section>
                        <h2>for-of 루프</h2>
                        <ul>
                            <li>for–of 루프 구문은 배열의 요소들, 즉 data를 순회하기 위한 구문.</li>
                            <li>for-in은 속성의 키(key)를 반복, for-of는 속성의 값(value)을 반복.</li>
                        </ul>
                        <p></p>
                        <p></p>

                        <pre><code>
    //문자열
    for (var i in 'string') { console.log(i); } //0, 1, 2, 3, 4, 5
    for (var i of 'string') { console.log(i); } //s, t, r, i, n, g

    //배열
    let array = [3, 5, 7];
    array.foo = 'bar';
    for (let j in array) { console.log(j); } // 0, 1, 2, foo
    for (let j of array) { console.log(j); } // 3, 5, 7
    //배열에서 foo라는 임의의 속성을 자동으로 걸러주고, 정상적인 요소만 표시

    //DOM
    var domArr = document.getElementsByTagName('div');
    for (var k = 0; k < domArr.length; k++) { console.log(domArr[k]); }

    for (let l of document.getElementsByTagName('div')) { console.log(l); }
                        </code></pre>

                        <aside class="notes">
                        </aside>
                    </section>
                </section>


                <section>
                    <section><h2>collections</h2></section>

                    <section>
                        <h2>Map</h2>
                        <p>Map 객체는 Object와 유사. Object와 차이점은 넣은 순서가 보장되고, <br>key가 문자열 뿐만 아니라 어떤 type도 가능합니다.</p>
                        <ul>
                            <li>key-value 쌍으로 이루어진 자료구조.</li>
                            <li>저정된 순서대로 각 요소들을 반복적으로 접근. (for...of)</li>
                            <li>key들은 중복될 수 없으며, 하나의 키에 하나의 value값.</li>
                        </ul>
                        <pre class="vertical"><code>
    let data = new Map();

    data.set('foo', 123);
    data.get('foo'); // 123

    data.has('foo'); // true
    data.delete('foo')
    data.has('foo'); // false

    //data.foo;
    //이렇게 사용 할 수 없음

                        </code></pre>

                        <pre class="vertical"><code>
    let data = new Map();

    data.set('foo', true);
    data.set(1, 'Number 1');

    data.size; // 2
    data.clear();
    data.size; // 0

    for (let [key, value] of data) {
      console.log(key, value);
    }
                        </code></pre>

                        <aside class="notes">
                        map 객체에 값을 할당할 때에는 set 메소드를, 값을 추출할 때는 get 메소드를 사용하여 접근한다.
                        </aside>
                    </section>

                    <section>
                        <h2>Set</h2>
                        <p>Set은 Array와 유사. Array와 차이점은 값이 중복될 수 없습니다.</p>
                        <ul>
                            <li>Set은 type 상관없이 유일한 값들의 집합.</li>
                            <li>입력된 순서에따라 저장된 요소를 반복처리. (for...of)</li>
                        </ul>
                        <pre class="vertical"><code>
    let data = new Set();

    data.add('red');

    data.has('red'); // true
    data.delete('red'); // true
    data.has('red'); //false

    //data[1];
    //이렇게 값을 하나씩 확인 불가능


                        </code></pre>
                        <pre class="vertical"><code>
    let data = new Set();

    data.add('red');
    data.add('green');

    data.size; //2
    data.clear();
    data.size; //0

    for (let item of data) {
      console.log(item);
    }
                        </code></pre>

                        <aside class="notes">
                        Set과 배열은 유사하지만 배열의 경우 중복된 값을 허용되고, Set은 중복값을 허용하지 않습니다.
                        set 에 이미 존재하는 값을 추가하려고 시도하면, 아무런 일도 일어나지 않습니다.
                        </aside>
                    </section>



                    <section>
                        <h2>WeakMap, WeakSet</h2>
                        <ul>
                            <li>WeakMap은 객체만 키로 허용하고, WeakSet도 객체만 요소로 허용.</li>
                            <li>저장된 객체를 참조하는 값이 없을 경우 가비지 콜력션의 대상. (약한참조)</li>
                            <li>키(key)들을 열거할 수 없어서 크기를 알 수 없음.</li>
                        </ul>
                        <p></p>

                        <pre class="vertical"><code>
    var weakMapObj = {
        example: 'any'
    };

    var weakMap = new WeakMap();
    weakMap.set(weakMapObj, 'zero');
    weakMap.get(weakMapObj); //zero

                        </code></pre>
                        <pre class="vertical"><code>
    var weakSetObj = {
        example: 'any'
    };

    var weakSet = new WeakSet();
    weakSet.add(weakSetObj);


                        </code></pre>

                        <aside class="notes">
                        map, set은 키로 어떤 타입도 가능했지만
                        WeakMap과 WeakSet을 사용하면 이러한 메모리 낭비를 막고 성능을 개선할 수 있다.
                        객체에 대한 참조가 더이상 존재하지 않을경우 가비지 컬렉션의 대상이 된다. 즉, 언제든지 오브젝트가 GC의 대상이 될수 있기 때문에 WeakMap은 키들의 열거형을 지원하지 않는다.

                        http://chanlee.github.io/2016/08/15/hello-es6-part-3/
                        </aside>
                    </section>


                </section>


                <section>
                    <section><h2>template literals</h2></section>

                    <section>
                        <h2>템플릿 문자열</h2>
                        <ul>
                            <li>템플릿 문자열은 문자열을 쉽게 다루도록 도와주는 문법.</li>
                            <li>+ 연산자를 사용하지 않아도 간단한 방법으로 새로운 문자열을 삽입 가능.</li>
                        </ul>

                        <pre><code>
    let a = 20;
    let b = 10;
    let c = '자바스크립트';

    //ES5
    var str = '나는 ' + (a + b) + '살이고' + c + '를 좋아해';

    //ES6
    let str = '나는 ${a + b}살이고 ${c}를 좋아해';

    console.log(str); // -> 나는 30살이고 자바스크립트를 좋아해
                        </code></pre>

                        <aside class="notes">
                        템플릿 대입문은 큰 따옴표, 작은 따옴표 대신 역 따옴표(back-tick)로 묶고, 코드는 달러 기호와 중괄호로 묶습니다.
                        </aside>
                    </section>

                    <section>
                        <h2>여러 줄 문자열</h2>
                        <ul>
                            <li>‘ 또는 “ 같은 따옴표 문자 대신 ` 백틱(backtick)문자를 사용.</li>
                            <li>줄바꿈과 들여쓰기 등 템플릿 문자열 속의 모든 white-space들은 있는 그대로 포함.</li>
                        </ul>

                        <pre><code>
    //ES5
    var html = '';
        html += '&lt;div&gt;';
        html += '   &lt;p&gt;Hello World&lt;/p&gt;';
        html += '&lt;/div&gt;';

    //ES6
    let html = `&lt;div&gt;
                    &lt;p&gt;Hello World&lt;/p&gt;
                &lt;/div&gt;`;
                        </code></pre>

                        <aside class="notes">
                        일반 문자열과 비슷해 보이지만,
                        숫자키 1번 옆에
                        </aside>
                    </section>

                </section>


                <section>
                    <section><h2>classes</h2></section>

                    <section>
                        <h2>객체지향 자바스크립트</h2>
                        <p>Javascript는 프로토타입 기반(prototype-based) 객체지향형 언어입니다.</p>

                        <pre><code>
    function SponsorWidget(name, description, url){
        this.name = name;
        this.description = description;
        this.url = url;
    }

    SponsorWidget.prototype.render = function(){
        //...
    };

    //SponsorWidget 함수호출
    var sponsorWidget = new SponsorWidget(name, description, url);
    sponsorWidget.render();
                        </code></pre>

                        <aside class="notes">
자바스크립트 개발을 해본 경험이 있다면 대부분 프로토타입(Prototype)에 대해서 들어봤을 것이다.

프로토타입은 클래스가 없는 자바스크립트에서 객체지향적인 프로그래밍을 하기 위해서 사용하는 특징이라고 할 수 있다.
좀 더 쉽게 말하자면 상속(Inheritance)을 구현하여 객체가 다른 객체에 속성들을 물려줄 수 있도록 하기 위해 프로토타입을 사용할 수 있는 것이다.



JavaScript는 클래스라는 개념이 없습니다.
그래서 기존의 객체를 복사하여(cloning) 새로운 객체를 생성하는 프로토타입 기반의 언어입니다.

프로토타입 기반 언어는 객체 원형인 프로토타입을 이용하여 새로운 객체를 만들어냅니다.
이렇게 생성된 객체 역시 또 다른 객체의 원형이 될 수 있습니다.
프로토타입은 객체를 확장하고 객체 지향적인 프로그래밍을 할 수 있게 해줍니다.




4. 코드의 재사용
코드의 재사용 하면 떠오르는 단어는 바로 상속입니다.
클래스라는 개념이 있는 Java에서는 중복된 코드를 상속받아 코드 재활용을 할 수 있습니다.
하지만 JavaScript에서는 클래스가 없는, 프로토타입 기반 언어입니다.
 그래서 프로토타입을 이용하여 코드 재사용을 할 수 있습니다.


자바스크립트의 모든 객체는 자신의 부모 역할을 하는 객체와 연결되어 있다.
그리고 이것은 마치 객체 지향의 상속 개념과 같이 부모 객체의 프로퍼티 또는 메서드를 상속받아 사용할 수 있게 한다. 이러한 부모 객체를 Prototype(프로토타입) 이라 한다.

Javascript에서는 기본 데이터 타입인 boolean, number, string, 그리고 특별한 값인 null, undefined 빼고는
모두 객체입니다.
사용자가 정의한 함수도 객체이고, new라는 연산자를 통해 생성된 것도 객체입니다.

                        </aside>
                    </section>

                    <section>
                        <h2>Javascript 프로토타입(Prototype)</h2>
                        <p>숫자, 문자열, 불리언(true/false), null, undefied를 제외한 모든 값은 객체</p>
                        <p>자바스크립트의 모든 객체는 자신의 부모 역할을 하는 객체와 연결되어 있고<br>부모 객체의 프로퍼티, 메소드를 상속받아 사용할 수 있습니다.</p>

                        <p>이러한 부모 객체를 Prototype(프로토타입)</p>
                    </section>


                    <section>
                        <p>student 객체는 __proto__ ( [[Prototype]] )라는 프로퍼티에 <br>자신의 부모 객체인 Object.prototype을 연결(Link)</p>
                        <pre><code>
    var student = {
        name: 'Kim',
        score: 90
    };

    console.log(student.valueOf()); //Object {name: "Kim", score: 90}
    console.log(student.__proto__ === Object.prototype); //true
                        </code></pre>

                        <img src="img/proto.png" alt="">

                        <aside class="notes">
                        프로토타입은 새로운 객체가 생성되기 위한 원형이 되는 객체.

                        ECMAScript spec에서는 자바스크립트의 모든 객체는 자신의 프로토타입을 가리키는 [[Protytpe]]이라는 숨겨진 내부 프로터피를 가지고 있으며,

                        크롬, 파이어폭스 등에서는 __proto__ 프로퍼티로 구현되어 있습니다.

                        student 객체의 __proto__ 프로퍼티가 가리키는 객체가 바로 Object.prototype 객체이며 hasOwnProperty(), toString(), valueOf() 등과 같은 모든 객체에서 호출 가능한 자바스크립트 기본 내장 메서드가 포함되어 있다.

                        그 결과 student 객체는 student.valueOf(), student.toString()등을 마치 자신의 프로퍼티인 것처럼 상속받아 사용할 수 있다.
                        </aside>
                    </section>

                    <section>
                        <p>모든 객체의 프로토타입은 객체를 생성할 때 결정됩니다.</p>
                        <ul>
                            <li>Object.prototype</li>
                            <li>Array.prototype</li>
                            <li>Function.prototype</li>
                        </ul>
                    </section>


                    <section>
                        <h2>Object.prototype</h2>
                        <p>객체 리터럴 방식으로 생성된 객체의 경우 부모는 Object.prototype.</p>
                        <p>Object.prototype은 자바스크립트 모든 객체의 최상위 부모.</p>
                        <aside class="notes">
                        </aside>

                    </section>

                    <section>
                        <h2>Object.prototype</h2>
                        <img src="img/proto_object.png" alt="" style="width:70%">
                    </section>



                    <section>
                        <h2>Array.prototye</h2>
                        <p>배열의 부모역할을 하는 객체는 Array.prototype.</p>
                        <p>모든 배열에 존재하는 length, push(), pop().. 등과 같은 메서드들은<br> Array.prototype 객체의 프로퍼티</p>

                        <pre><code>
    var myArray = [];
    console.log(myArray);
                        </code></pre>

                        <img src="img/proto_array.png" alt="">

                        <aside class="notes">
                        배열도 자바스크립트의 객체다. 자바스크립트의 모든 객체는 자신의 부모역할을 하는 객체와 연결되어 있기 때문에 배열 또한 Array.prototype 객체가 프로토타입이다.
                        </aside>

                    </section>

                    <section>
                        <h2>Array.prototye</h2>
                        <img src="img/proto_object2.png" alt="" style="width:70%">
                    </section>

                    <section>

                        <h2>Function.prototye</h2>
                        <p>함수의 부모 객체는 Function.prototype</p>
                        <pre><code>
    function sum(x, y) {
        //...
    }
                        </code></pre>

                        <img src="img/proto_function.png" alt="">

                        <aside class="notes">
                        사실 function 함수엔 Prototype 객체를 가르키는 prototype 이란 프로퍼티가 하나 존재합니다.
                        이 Prototype 객체에 공유되어  있는 프로퍼티와 메소드가 객체 생성시 해당 생성자 function 으로
                        생성한 모든 인스턴스에서 공유됩니다...
                        </aside>



                    </section>


                    <section>
                        <h2>Function.prototye</h2>
                        <img src="img/proto_object3.png" alt="" style="width:90%">
                    </section>


                    <section>
                        <h2>Class 다루기</h2>
                        <p>class를 선언하기 위해서는 class 키워드를 사용합니다.</p>

                        <pre><code>
    class SponsorWidget {
        //클래스 본문
    }
                        </code></pre>

                        <aside class="notes">
                        이제 자바스크립트도 클래스가 있습니다!
                        생성자를 만들고 상속을 다루는 훨씬 간결하고 단정한 구문
                        </aside>
                    </section>


                    <section>
                        <h2>생성자 함수 값 초기화</h2>
                         <p>constructor는 객체 초기화를 위해 사용되는 특수한 메소드</p>

                        <pre><code>
    //new 연산자로 생성된 새로운 인스턴스가 있을 때 마다 실행
    class SponsorWidget {
        constructor(name, description, url){
            this.name = name;
            this.description = description;
            this.url
        }

        render(){
            //...
        }
    }

    //new 연산자를 사용하지 않고 객체를 생성하면 에러가 발생
    let sponsorWidget = new SponsorWidget(name, description, url);
    sponsorWidget.render();

    let widget2 = new SponsorWidget(name, description, url);
                        </code></pre>

                        <aside class="notes">

                        </aside>
                    </section>

                    <section>
                        <h2>클래스에서 멤버 변수 접근</h2>
                        <ul>
                            <li>constructor 메소드에 설정된 멤버 변수는 클래스의 모든 메소드에서 <br>사용가능합니다.</li>
                            <li>this를 이용해 멤버 변수, 메소드에 접근.</li>
                        </ul>
                        <pre><code>
    class SponsorWidget {
        constructor(name, description, url){
            //...
            this.url = url;
        }

        render(){
            let link = this._buildLink(this.url); //멤버 변수(this.url) 사용
        }

        _buildLink(url){ //메소드 앞에 밑줄이 있으면 내부에서만 사용 규칙
            //...
        }
    }
                        </code></pre>

                        <aside class="notes">

                        </aside>
                    </section>

                    <section>
                        <h2>그런데 ES6의 클래스는..</h2>
                        <p>ES6의 클래스가 새로운 객체지향 모델을 제공하는 것은 아닙니다. <br>기존 생성자 함수를 대신해 사용할 수 있는 편리한 구문. (Syntax sugar)</p>

                        <pre><code>
    //Syntactic Sugar
    class SponsorWidget {
        //...
    }

    //Prototype Object Model
    function SponsorWidget(name, description, url){
        //...
    }


    //인스턴스는 같은 방식으로 생성됩니다.
    let sponsorWidget = new SponsorWidget(name, description, url);
    sponsorWidget.render();

    console.log(typeof SponsorWidget); //function
                        </code></pre>

                        <aside class="notes">
                        es6부터는 class 키워드를 지원하기 시작했다. 그렇지만, 여전히 자바스크립트는 프로토타입 기반의 언어다.
                       ES6의 Class가 새로운 객체지향 모델을 제공하는 것이 아니며 Class도 사실 함수이고 기존 prototype 기반 패턴의 Syntax sugar일 뿐이다.
                        </aside>
                    </section>

                    <section>
                        <h2>extends 클래스 상속</h2>
                        <ul>
                        <li>extends 키워드는 메소드와 속성을 상속받는 자식 Class를 만드는데 사용.</li>
                        <li>super는 부모클래스를 참조하기 위한 키워드.</li>
                        </ul>
                        <pre><code>
    class Widget { //Parent Class
        constructor(){
            this.baseCSS = 'site-widget';
        }
        parse(value){
            //...
        }
    }
    class SponsorWidget extends Widget { //Child Class
        constructor(name, description, url){
            super();
            //super() 함수가 먼저 호출되어야 'this' 키워드를 사용가능
            this.name = 'Square';
        }
        render(){
            let parsedName = this.parse(this.name); //Parent 메소드 상속
            let css = this._buildCSS(this.baseCSS); //Parent 변수 상속
        }
    }
                        </code></pre>

                        <aside class="notes">
                        상속이란 자식 클래스(서브 클래스)에서 부모 클래스(슈퍼 클래스)의 필드와 메소드를 참조하여 쓸 수 있게 해준다.
                        함수의 상속 계층 구현은 쉬운일이 아닙니다.

                        클래스 constructor메소드에서 부모클래스 constructor 호출
                        </aside>
                    </section>

                    <section>
                        <h3>부모 클래스 메소드 재선언 시</h3>
                        <p>Child Class는 super 객체를 통해 Parent Class 메소드를 호출 할 수 있습니다.</p>

                        <pre><code>
    class Widget { //Parent Class
        constructor(){
            this.baseCSS = 'site-widget';
        }
        parse(value){
            //...
        }
    }
    class SponsorWidget extends Widget { //Child Class
        constructor(name, description, url){
            super();
        }
        parse(){
            //Parent Class의 parse() 메소드 호출
            let parsedName = super.parse(this.name);
        }
        render(){
            //...
        }
    }
                        </code></pre>

                        <aside class="notes">
                        super 키워드는 부모 객체의 메소드를 호출하는데 사용
                        멤버변수는 같은 class 안에서 존재하므로 같은 member method 에서는 그 변수를 사용할 수 있다.
                        </aside>
                    </section>

                </section>


                <section>
                    <section><h2>modules - part I</h2></section>

                    <section>
                        <h2>Javascript의 전역은 매우 쉽게 오염된다.</h2>
                        <p>Javascript는 일반적으로 전역변수를 사용합니다.<br> 이로인해 예기치 않은 문제점들이 발생할 가능성이 높아집니다.</p>

                        <pre style="margin-bottom:0"><em class="file_name">index.html</em><code>
    &lt;!DOCTYPE&nbsp;html&gt;
    &lt;body&gt;
    &lt;script src="./jquery.js"&gt;&lt;/script&gt;
    &lt;script src="./underscore.js"&gt;&lt;/script&gt;
    &lt;script src="./flash-message.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
                        </code></pre>
                        <pre style="margin-top:0"><code>
    let element = $("...").find(...);
    let filtered = _.each(...);
    flashMessage("Hello");

    //라이브러리들이 Global Namespace에 추가
    //전역변수 사용으로 인해
    //네이밍이 충돌 될 수 있는 잠재적인 오류가 발생 할 수 있습니다.
    //필요한 코드와 필요하지 않는 코드를 구분하는 것이 매우 어려운 일
                        </code></pre>

                        <aside class="notes">
                        Global Namespace를 오염시키는..
                        Import를 하는 다른 파일에서 동일한 이름의 전역변수가 있으면 Override됨
                        비동기 모듈정의 AMD

                        모듈러 프로그래밍 프로그램과 라이브러리를 모듈 단위로 잘개 나누는 행위
                        자바스크립트 모듈 객체, 함수기타 콤포넌트를 함께 말아넣은 콜렉션
                        코드를 여러모듈로 분리 깔끔하게 기획하고 조직화
                        각자 자신의 스코프를 가지므로 전역변수 사용을 줄이고 그로 인한 문제점을 예방
                        코드 재사용성이 좋아진다.
                        특정 모듈에 버그가 한정 되므로 디버깅이 쉽다.

                        지금 필요한 코드와 필요하지 않는 코드를 구분하는 것이 매우 어려운 일이 될겁니다.
                        </aside>
                    </section>

                    <section>
                        <h2>모듈(modules) 정의</h2>
                        <ul>
                            <li>하나가 코드를 여러개의 파일로 분리하는 것.</li>
                            <li>전역변수 사용을 줄이고 그로 인한 문제점을 예방.</li>
                            <li>자주 사용되는 코드를 별도의 파일로 만들어 필요할 때마다 재사용.</li>
                        </ul>

                        <aside class="notes">
                        프로그램은 작고 단순한 것에서 크고 복잡한 것으로 진화
                        그 과정에서 코드의 재활용성을 높이고 유지보수를 쉽게 할 수있는 다양한 기법들이 사용
                        </aside>

                    </section>


                    <section>
                        <h2>모듈 생성</h2>
                        <p>export 키워드를 사용해 모듈을 외부로 보낼 수 있습니다.</p>

                        <pre><em class="file_name">flash-message.js</em><code>
    //messages를 표시하기 위한 모듈 생성합니다.
    //default type export는 하나의 함수를 내보내는 방법입니다.

    export default function(message){
        alert(message);
    }
                        </code></pre>

                        <aside class="notes">
                        기본 익스포트가 변수 한 개만 익스포트할 때 쓰는 반면, 명명된 익스포트는 변수 여럿을 익스포트하기 위해 사용
                        </aside>
                    </section>

                    <section>
                        <h2>default export - 모듈 가져오기</h2>
                        <ul>
                        <li>모듈을 가져오려면 import키워드를 사용합니다.</li>
                        <li>내용을 저정할 로컬변수를 지정하고</li>
                        <li>from 키워드를 사용하여 모듈이 위치한 경로를 작성합니다.</li>
                        </ul>

                        <pre><em class="file_name">app.js</em><code>
    //default export로 보내면 이름을 지정할 수 있습니다.

    import flashMessage from './flash-message'; //.js파일확장자는 생략
    flashMessage('Hello');
                        </code></pre>

                        <pre><em class="file_name">flash-message.js</em><code>
    export default function(message){
        alert(message);
    }
                        </code></pre>

                        <aside class="notes">

                        </aside>
                    </section>

                    <section>
                        <h2>모듈 코드 실행</h2>
                        <p>모듈은 이전과 같이 script태그를 통해 가져옵니다.<br> 그러나 더 이상 전역 네임스페이스가 오염되지 않습니다.</p>

                        <pre><em class="file_name">index.html</em><code>
    &lt;!DOCTYPE html&gt;
    &lt;body&gt;
    &lt;script src="./app.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
                        </code></pre>

                        <div><img src="img/alert_1.png" alt=""></div>

                        <aside class="notes">

                        </aside>
                    </section>

                    <section>
                        <h2>default export - 여러 함수를 내보낼 수 없음</h2>
                        <p>default export는 모듈에서 내보낼 수 있는 함수의 수를 제한</p>

                        <pre><em class="file_name">flash-message.js</em><code>
    export default function(message){
        alert(message);
    }

    //consoleMessage 함수는 모듈 외부에서 사용할 수 없습니다.
    function consoleMessage(message){
        console.log(message);
    }
                        </code></pre>

                        <aside class="notes">

                        </aside>
                    </section>

                    <section>
                        <h2>named export - 내보내기</h2>
                        <p>단일 모듈에서 여러 함수를 내 보내려면 named(명명된) Export를 사용할 수 있습니다.</p>

                        <pre><em class="file_name">flash-message.js</em><code>
    //export뒤에 default type을 사용하지 않습니다.

    export function alertMessage(message){
        alert(message);
    }

    export function consoleMessage(message){
        console.log(message);
    }
                        </code></pre>

                        <aside class="notes">

                        </aside>
                    </section>

                    <section>
                        <h2>named export - 가져오기</h2>
                        <p>named(명명된) export 함수 이름과 동일한 이름을 변수로 중괄호 안에 묶어야합니다.</p>

                        <pre><em class="file_name">app.js</em><code>
    import { alertMessage, consoleMessage } from './flash-message';

    alertMessage('Hello from alert');
    consoleMessage('Hello from log');
                        </code></pre>

                        <p style="text-align:left">함수이름이 일치해야합니다.</p>

                        <pre><em class="file_name">flash-message.js</em><code>
    export function alertMessage(message){
        alert(message);
    }

    export function consoleMessage(message){
        console.log(message);
    }
                        </code></pre>

                         <div style="position:absolute;top:330px;right:0px"><img src="img/alert_2.png" alt=""></div>
                         <div style="position:absolute;top:500px;right:0px"><img src="img/alert_3.png" alt=""></div>

                        <aside class="notes">

                        </aside>
                    </section>

                    <section>
                        <h2>모듈을 객체로 가져오기</h2>
                        <p>전체 모듈을 객체로 가져와서 객체의 속성으로 호출할 수 있습니다.</p>

                        <pre><em class="file_name">app.js</em><code>
    import * as flash from './flash-message';

    flash.alertMessage('Hello from alert');
    flash.consoleMessage('Hello from log');
                        </code></pre>

                        <p style="text-align:left">함수가 객체 속성이됩니다.</p>

                        <pre><em class="file_name">flash-message.js</em><code>
    export function alertMessage(message){
        alert(message);
    }

    export function consoleMessage(message){
        console.log(message);
    }
                        </code></pre>

                         <div style="position:absolute;top:330px;right:0px"><img src="img/alert_2.png" alt=""></div>
                         <div style="position:absolute;top:500px;right:0px"><img src="img/alert_3.png" alt=""></div>

                        <aside class="notes">

                        </aside>
                    </section>


                    <section>
                        <h2>반복되는 export 제거</h2>
                        <p>함수를 외부로 보낼 때마다 export 명령문을 사용합니다.</p>

                        <pre><em class="file_name">flash-message.js</em><code>
    export function alertMessage(message){
        alert(message);
    }

    export function consoleMessage(message){
        console.log(message);
    }
                        </code></pre>

                        <aside class="notes">

                        </aside>
                    </section>

.
                    <section>
                        <h2>한 번에 여러 함수 내보내기</h2>
                        <p>여러 함수를 중괄호에 묶어서 한 번에 외부로 보낼 수 있습니다</p>

                        <pre><em class="file_name">flash-message.js</em><code>
    function alertMessage(message){
        alert(message);
    }

    function consoleMessage(message){
        console.log(message);
    }
    export { alertMessage, consoleMessage }
    //중괄호 안에 여러 함수 이름을 작성 할 수 있습니다.
                        </code></pre>

                        <pre><em class="file_name">app.js</em><code>
    //이전과 마찬가지로 가져옵니다.
    import { alertMessage, consoleMessage } from './flash-message';

    alertMessage('Hello from alert');
    consoleMessage('Hello from log');
                        </code></pre>

                        <aside class="notes">

                        </aside>
                    </section>

                </section>



                <section>
                    <section>
                        <h2>modules - part II</h2>
                    </section>

                    <section>
                        <h2>하드코딩된 상수 모듈화</h2>
                        <p>응용프로그램에서 상수를 재정의 하는 것은 불필요한 반복이고,<br> 버그로 이어질 수 있습니다.</p>
                    </section>


                    <section>
                        <pre style="margin:0 auto"><em class="file_name">load-profiles.js</em><code>
    function loadProfiles(userNames){
        const MAX_USERS = 3; //상수를 정의
        if(userNames.length > MAX_USERS){
            //...
        }
        const MAX_REPLIES = 3; //상수를 정의
        if(someElement > MAX_REPLIES){
            //...
        }
    }
    export { loadProfiles }
                        </code></pre>

                        <pre class="vertical"><em class="file_name">list-replies.js</em><code>
    function listReplies(replies=[]){
      const MAX_REPLIES = 3;
      //다른곳에도 다시 정의
      if(replies.length > MAX_REPLIES){
        //...
      }
    }
    export { listReplies }
                        </code></pre>

                        <pre class="vertical"><em class="file_name">display-watchers.js</em><code>
    function displayWatchers(watchers=[]){
      const MAX_USERS = 3;

      if(watchers.length > MAX_USERS){
        //...
      }
    }
    export { displayWatchers }
                        </code></pre>


                        <aside class="notes">

                        </aside>
                    </section>


                    <section>
                        <h2>상수 내보내기</h2>
                        <p>모듈에 상수를 배치하면 다른 모듈에서 재사용 할 수 있습니다.</p>

                        <pre><em class="file_name">constants.js</em><code>
   /*
    export const MAX_USERS = 3;
    export const MAX_REPLIES = 3;
    */

    const MAX_USERS = 3;
    const MAX_REPLIES = 3;

    export { MAX_USERS, MAX_REPLIES };
                        </code></pre>

                        <aside class="notes">

                        </aside>
                    </section>

                    <section>
                        <h2>상수를 가져오는 방법</h2>
                        <p>상수를 가져오려면, 함수를 가져올 때와 같은 구문을 사용할 수 있습니다.</p>

                        <pre><em class="file_name">load-profiles.js</em><code>
    import { MAX_REPLIES, MAX_USERS } from './constants';

    function loadProfiles(userNames){
        if(userNames.length > MAX_USERS){
            //...
        }
        if(someElement > MAX_REPLIES){
            //...
        }
    }
                        </code></pre>
                        <aside class="notes">

                        </aside>
                    </section>

                    <section>
                        <h2>상수 가져오기</h2>
                        <p>이제 다른 파일에서도 상수를 가져와서 사용할 수 있습니다.</p>
                        <pre><em class="file_name">list-replies.js</em><code>
    import { MAX_REPLIES } from './constants';

    function listReplies(replies = []){
        if(replies.length > MAX_REPLIES){
            //...
        }
    }
                        </code></pre>

                        <pre><em class="file_name">display-watchers.js</em><code>
    import { MAX_USERS } from './constants';

    function displayWatchers(watchers = []){
        if(watchers.length > MAX_USERS){
            //...
        }
    }
                        </code></pre>
                        <aside class="notes">

                        </aside>
                    </section>

                    <section>
                        <h2>default export - 클래스 모듈 내보내기</h2>
                        <p>클래스도 함수와 동일한 구문을 사용해 모듈에서 내보낼 수 있습니다.</p>

                        <pre><em class="file_name">flash-message.js</em><code>
    //default는 이 클래스를 가져 올 때 이름을 변경 할 수 있습니다.
    export default class FlashMessage {
        constructor(message){
            this.message = message;
        }

        renderAlert(){
            alert(`${this.message} from alert`);
        }

        renderConsole(){
            console.log(`${this.message} from log`);
        }
    }
                        </code></pre>
                        <aside class="notes">
                        2개의 개별 함수 대신에, 이제 클래스의 일부인 2개의 인스턴스 메소드가 있습니다.
                        </aside>
                    </section>


                    <section>
                        <h2>default export - 클래스 모듈 사용</h2>
                        <p>import를 사용해 가져온 클래스는 변수에 할당되고,<br> 새로운  인스턴스를 만드는데 사용할 수 있습니다.</p>

                        <pre><em class="file_name">flash-message.js</em><code>
    export default class FlashMessage {
        //...
    }
                        </code></pre>

                        <pre><em class="file_name">app.js</em><code>
    import MyMessage from './flash-message'; //변수 이름 변경

    //인스턴스를 생성하고, 인스턴스 메소드를 호출합니다.
    let flash = new MyMessage('Hello');
    flash.renderAlert();
    flash.renderConsole();
                        </code></pre>

                        <div style="position:absolute;top:280px;right:0px"><img src="img/alert_4.png" alt=""></div>
                        <div style="position:absolute;top:530px;right:0px"><img src="img/alert_5.png" alt=""></div>
                        <aside class="notes">

                        </aside>
                    </section>

                    <section>
                        <h2>named export - 클래스 모듈 내보내기</h2>
                        <p>클래스를 내보내는 또 다른 방법으로 <br>클래스를 먼저 정의한 다음, 중괄호 안에 클래스 이름과 함께 export를 사용합니다.</p>

                        <pre><em class="file_name">flash-message.js</em><code>
    class FlashMessage { //일반적인 클래스 선언
        constructor(message){
            this.message = message;
        }

        renderAlert(){
            alert(`${this.message} from alert`);
        }

        renderLog(){
            console.log(`${this.message} from log`);
        }
    }

    export { FlashMessage } //외부로 클래스를 보냅니다.
                        </code></pre>

                        <aside class="notes">

                        </aside>
                    </section>

                    <section>
                        <h2>named export - 클래스 모듈 사용</h2>
                        <p>마찬가지로 named(명명된) export, import를 사용할 때는<br> 클래스 이름과 동일한 이름을 변수로 중괄호 안에 묶어야합니다.</p>

                        <pre><em class="file_name">flash-message.js</em><code>
    class FlashMessage {
        //...
    }
    export { FlashMessage }
                        </code></pre>
<p style="text-align:left">중괄호 안에 이름 일치</p>
                        <pre><em class="file_name">app.js</em><code>
    import { FlashMessage } from './flash-message';

    let flash = new FlashMessage("Hello");
    flash.renderAlert();
    flash.renderLog();
                        </code></pre>

                        <div style="position:absolute;top:330px;right:0px"><img src="img/alert_4.png" alt=""></div>
                        <div style="position:absolute;top:540px;right:0px"><img src="img/alert_5.png" alt=""></div>
                        <aside class="notes">
                        이제 ES6모듈을 이용하여 자바스크립트 애플리케이션을 제작할 수 있을 것입니다.
                        </aside>
                    </section>
                </section>


                 <section>
                    <section><h2>promise</h2></section>

                    <section>
                        <h2>이전의 비동기식 프로그래밍 구현 방법</h2>
                        <p>Callback Hell은 코드의 가독성이 떨어져 이해하기 어럽고,<br> 실수를 유발시킬 확률이 높습니다.</p>

                        <pre><code>
    async1(function(input, result1) {
        async2(function(result2) {
            async3(function(result3) {
                async4(function(result4) {
                    async5(function(output) {
                        // do something with output
                    });
                });
            });
        });
    });
                        </code></pre>

                        <aside class="notes">
                        여러개의 콜백함수가 중첩되어 복잡도가 높아지는 Callback Hell 됩니다.
                        중첩된 함수 호출을 따라가야 하므로 가독성이 현저히 떨어진다.
                        비동기 처리를 순차적으로 처리해야 하는 상황이 발생
                        비동기 A,B,C 요청을 보낸 후 모두 처리가 끝난 후에 처리
                        비동기 A,B 요청을 보낸 후 그 결과를 사용하여 C요청을 보내야 하는 경우
                        </aside>
                    </section>


                    <section>
                        <h2>promise 선언</h2>
                        <p>Promise는 비동기 처리가 성공, 실패 했는지 상태 정보와<br> 처리 종료 후 실행될 콜백함수 then() 담고 있는 객체입니다.</p>

                        <pre><code>
    let asyncFunction = function(param) {
        return new Promise(function(resolve, reject) {

             //비동기 함수
            setTimeout(function() {
                //처리가 끝나면 resolve 또는 reject을 반환
                if (param) {
                    resolve('성공');
                } else {
                    reject(Error('실패'));
                }
            }, 2000);

        });
    };
                        </code></pre>

                        <aside class="notes">
                        이러한 문제를 극복하기 위해 Promise가 제안되었다.
                        Promise는 기본적으로 생성자를 통해서 만들 수 있습니다.

                        이벤트 콜백 패턴의 골칫거리를 한번에 해소
                        비동기 코드를 쉽게 작성할 수 있도록 Promise를 표준 라이브러리에 도입하였습니다.
                        promise 객체를 반환
                        </aside>
                    </section>

                    <section>
                        <h2>promise 실행</h2>
                        <p>비동기 처리가 성공적으로 끝났을 때 호출될 콜백을 promise 객체의 then() 정의.</p>
                        <p>실패했을 때 호출될 콜백은 catch() 정의.</p>
                        <pre><code>

    asyncFunction(true).then(function(data) {
        // resolve가 실행된 경우(성공)
        console.log(data);

    }).catch(function(error) {
        // reject가 실행된 경우(실패)
        console.error(error);
    });

                        </code></pre>

                        <aside class="notes">
비동기 처리가 성공적으로 끝났을 때 호출될 콜백을 promise 객체의 then()으로 등록한다. 실패했을 때 호출될 콜백은 catch()로 등록한다.
                        </aside>
                    </section>



                </section>

                 <section>
                    <section><h2>generators</h2></section>

                    <section>
                        <h2>generators</h2>

                        <p>실행 중간에 값을 반환할 수 있고, 다른 작업을 처리한 후,<br> 다시 그 위치에서 코드를 시작.</p>

                        <ul>
                        <li>function* 표기</li>
                        <li>next()메소드 실행 시 yield키워드를 만나면 실행을 중지, yield된 값을 반환</li>
                        <li>다시 next() 메소드가 호출되면 진행이 멈췄던 부분에서부터 실행, yield된 값 반환</li>
                        <li>done 프로퍼티로 generator 함수의 완료여부 확인</li>
                        </ul>

                        <pre><code>
    function* generatorFunction() {
        yield 1;
        yield 2;
        yield 3;
    }

    let generator = generatorFunction();

    console.log(generator.next().value); //1
    console.log(generator.next().value); //2
    console.log(generator.next().value); //3
    console.log(generator.next().done);  //true
                        </code></pre>

                        <aside class="notes">
                        Generator를 사용하면 함수의 처리를 일시 정지하거나 재개할 수 있다.
                        </aside>

                    </section>
                </section>



                <section>
                    <h1><a href="http://vanilla-js.com/" target="_blank">Vanilla JS</a></h1>

                    <p>기본의 충실함.</p>

                    <aside class="notes">
                    프레임워크와 라이브러리의 사용이 잘못되었음을 지적하는 것이 아닌
                    간단한 페이지를 만드는 데도 jQuery가 없으면 아무런 개발을 하지 못하거나
                    React, Angular를 사용하면 모든것이 해결 될 것이라는 생각이 퍼지면서
                    프론트 개발자라는 느낌보다는
                    jQuery개발자, Angular개발자, React개발자가 되어버리는게 아닌가 라는 생각이 듭니다.
                    위와같은 현상의 반대 급부로 등장하는것이 바로 Vanilla JS 입니다.
                    </aside>
                </section>

                <section>
                    <h1>감사합니다.</h1>
                </section>
            </div>

        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>
        <script>
            // Full list of configuration options available at:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,

                transition: 'convex', // none/fade/slide/convex/concave/zoom

                // Optional reveal.js plugins
                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/zoom-js/zoom.js', async: true },
                    { src: 'plugin/notes/notes.js', async: true }
                ]
            });

            Reveal.addEventListener( 'slidechanged', function(event) {
                // event.previousSlide, event.currentSlide, event.indexh, event.indexv
                var notes = event.currentSlide.querySelector(".notes");
                if(notes) {
                    console.info(notes.innerHTML.replace(/\n\s+/g,'\n'));
                }
            });
        </script>
    </body>
</html>
